// ========== LEXER ==========
// Definición de tokens

// Palabras reservadas
program      : 'p''r''o''g''r''a''m' ;
var          : 'v''a''r' ;
main         : 'm''a''i''n' ;
end          : 'e''n''d' ;
if           : 'i''f' ;
else         : 'e''l''s''e' ;
while        : 'w''h''i''l''e' ;
do           : 'd''o' ;
print        : 'p''r''i''n''t' ;
int          : 'i''n''t' ;
float        : 'f''l''o''a''t' ;
void         : 'v''o''i''d' ;

// Identificadores y constantes
_lowcase     : 'a'-'z' ;
_upcase      : 'A'-'Z' ;
_digit       : '0'-'9' ;
_symbol      : ' ' | '!' | '#' | '$' | '%' | '&' | '\'' | '(' | ')' | '*' | '+' | ',' | '-' | '.' | '/' |
            ':' | ';' | '<' | '=' | '>' | '?' | '@' |
            '[' | ']' | '^' | '_' | '`' | '{' | '|' | '}' | '~' ;
_chars       : _lowcase | _upcase | _digit | _symbol ;

id           : _lowcase { (_lowcase | _upcase | _digit) } ;
cte_int      : _digit { _digit } ;
cte_float    : _digit { _digit } '.' _digit { _digit } ;
cte_string   : '"' { _chars } '"' ;

// Operadores aritméticos
plus         : '+' ;
minus        : '-' ;
times        : '*' ;
divide       : '/' ;

// Comparadores
gt           : '>' ;
lt           : '<' ;
neq          : '!''=' ;

// Delimitadores
assign       : '=' ;
semicolon    : ';' ;
colon        : ':' ;
comma        : ',' ;
lparen       : '(' ;
rparen       : ')' ;
lbrace       : '{' ;
rbrace       : '}' ;
lbracket     : '[' ;
rbracket     : ']' ;

// Tokens ignorados
!whitespace  : ' ' | '\t' | '\n' | '\r' ;


// ========== PARSER ==========
// Definición de Producciones (Reglas de la Gramática)

<<
import(
    "BabyDuck_A00833578/ast"
    "BabyDuck_A00833578/token"
    "strconv"
)
>>

Program
    : program id semicolon VarOptional FuncSection main Body end
    <<
        func() (Attrib, error) {
            idTok := $1.(*token.Token)
            params := $3.([]*ast.ParamNode)
            body := $6.([]ast.Attrib)

            // Inicializar programa como una función
            programNode, err := ast.NewFunction(idTok, params, body)
            if err != nil {
                return nil, err
            }

            // Establecer ámbito global
            ast.SetGlobalScope(programNode.Id)

            // Ejecutar programa
            return nil, ast.ExecuteFunction(programNode)
        }()
    >>
    ;

// Declaración opcional de variables (0 o 1)
VarOptional
    : VarSection
    << $0, nil >>
    | "empty"
    << []*ast.ParamNode{}, nil >>
    ;

// Declaración de variables
VarSection
    : var VarList
    << $1, nil >>
    ;

// Secuencia de declaraciones de variables (1 o más)
VarList
    : VarDeclaration VarDeclarationTail
    <<
        func() (Attrib, error) {
            head := $0.([]*ast.ParamNode)
            tail := $1.([]*ast.ParamNode)
            return append(head, tail...), nil
        }()
    >>
    ;

// Secuencia opcional de declaraciones de variables (0 o más)
VarDeclarationTail
    : VarDeclaration VarDeclarationTail
    <<
        func() (Attrib, error) {
            head := $0.([]*ast.ParamNode)
            tail := $1.([]*ast.ParamNode)
            return append(head, tail...), nil
        }()
    >>
    | "empty"
    << []*ast.ParamNode{}, nil >>
    ;

// Declaración de una variable
VarDeclaration
    : IdList colon Type semicolon
    <<
        func() (Attrib, error) {
            ids := $0.([]*token.Token)
            typ := $2.(*token.Token)
            
            params := []*ast.ParamNode{}
            for _, id := range ids {
                paramNode := &ast.ParamNode{
                    Id:   id,
                    Type: typ,
                }
                params = append(params, paramNode)
            }
            return params, nil
        }()
    >>
    ;

// Lista de identificadores (1 o más)
IdList
    : id IdListTail
    <<
    func() (Attrib, error) {
        ids := []*token.Token{$0.(*token.Token)}
        ids = append(ids, $1.([]*token.Token)...)
        return ids, nil
    }()
    >>
    ;

// Secuencia de identificadores adicionales (0 o más)
IdListTail
    : comma id IdListTail
    <<
    func() (Attrib, error) {
        ids := []*token.Token{$1.(*token.Token)}
        ids = append(ids, $2.([]*token.Token)...)
        return ids, nil
    }()
    >>
    | "empty"
    << []*token.Token{}, nil >>
    ;

// Tipo de la variable
Type
    : int   << $0, nil >>
    | float << $0, nil >>
    ;

// Sección de funciones (0 o más)
FuncSection
    : FuncDeclaration FuncSection
    | "empty"
    ;

// Declaración de una función
FuncDeclaration
    : void id lparen FuncVarOptional rparen lbracket VarOptional Body rbracket semicolon
    <<
        func() (Attrib, error) {
            idTok := $1.(*token.Token)
            params := $3.([]*ast.ParamNode)
            vars := $6.([]*ast.ParamNode)
            body := $7.([]ast.Attrib)

            // Crear y registrar la función
            funcNode, err := ast.NewFunction(idTok, append(params, vars...), body)
            if err != nil {
                return nil, err
            }

            return funcNode, nil
        }()
    >>
    ;

// Declaración opcional de variables de función (0 o 1)
FuncVarOptional
    : FuncVarList
    << $0.([]*ast.ParamNode), nil >>
    | "empty"
    << []*ast.ParamNode{}, nil >>
    ;

// Declaración de variables de función (1 o más)
FuncVarList
    : FuncVarDeclaration FuncVarDeclarationTail
    <<
        func() (Attrib, error) {
            head := $0.(*ast.ParamNode)
            tail := $1.([]*ast.ParamNode)
            return append([]*ast.ParamNode{head}, tail...), nil
        }()
    >>
    ;

// Secuencia de declaraciones de variables de función (0 o más)
FuncVarDeclarationTail
    : comma FuncVarDeclaration FuncVarDeclarationTail
    <<
        func() (Attrib, error) {
            head := $1.(*ast.ParamNode)
            tail := $2.([]*ast.ParamNode)
            return append([]*ast.ParamNode{head}, tail...), nil
        }()
    >>
    | "empty"
    << []*ast.ParamNode{}, nil >>
    ;

// Declaración de una variable de función
FuncVarDeclaration
    : id colon Type
    << &ast.ParamNode{Id: $0, Type: $2}, nil >>
    ;

// Cuerpo de una función o bloque
Body
    : lbrace StatementOptional rbrace
    << $1, nil >>
    ;

// Declaración opcional de sentencias (0 o más)
StatementOptional
    : Statement StatementOptional
    <<
        func() (Attrib, error) {
            stmts := []ast.Attrib{$0}

            // Lista de statements
            if $1 != nil {
                stmts = append(stmts, $1.([]ast.Attrib)...)
            }
            return stmts, nil
        }()
    >>
    | "empty"
    << []ast.Attrib{}, nil >>
    ;

// Declaración de una sentencia
Statement
    : Assign
    << $0, nil >>
    | Condition
    | Cycle
    | F_Call
    | Print
    << $0, nil >>
    ;

// Asignación de un valor
Assign
    : id assign Expression semicolon
    <<
        func() (Attrib, error) {
            // Token de la variable a la que se le asigna algo
            idTok := $0.(*token.Token)

            // Expresión a la que se le asigna el valor
            exp := $2.(ast.Evaluable)

            // Crear el nodo de asignación
            return &ast.AssignNode{
                Id:  idTok,
                Exp: exp,
            }, nil
        }()
    >>
    ;

// Expresión
Expression
    : Exp ExpressionOptional
    <<
        func() (Attrib, error) {
            left := $0.(ast.Evaluable)
            
            if $1 == nil {
                return left, nil
            }

            // Extraer operador y operando derecho
            tail := $1.(struct {
                Operator ast.Attrib
                Right    ast.Evaluable
            })

            // Crear un nodo de expresión
            return &ast.ExpressionNode{
                Operator: tail.Operator,
                Left:     left,
                Right:    tail.Right,
            }, nil
        }()
    >>
    ;

// Secuencia opcional al final de una expresión (0 o 1)
ExpressionOptional
    : ExpressionTail
    << $0, nil >>
    | "empty"
    << nil, nil >>
    ;

// Operadores relacionales
ExpressionTail
    : gt Exp
    << 
        func() (Attrib, error) {
            return struct {
                Operator  ast.Attrib // Token del operador relacional
                Right     ast.Evaluable // Valor de la derecha
            }{
                Operator: $0.(ast.Attrib),
                Right:    $1.(ast.Evaluable),
            }, nil
        }()
    >>
    | lt Exp
    <<
        func() (Attrib, error) {
            return struct {
                Operator  ast.Attrib // Token del operador relacional
                Right     ast.Evaluable // Valor de la derecha
            }{
                Operator: $0.(ast.Attrib),
                Right:    $1.(ast.Evaluable),
            }, nil
        }()
    >>
    | neq Exp
    <<
        func() (Attrib, error) {
            return struct {
                Operator  ast.Attrib // Token del operador relacional
                Right     ast.Evaluable // Valor de la derecha
            }{
                Operator: $0.(ast.Attrib),
                Right:    $1.(ast.Evaluable),
            }, nil
        }()
    >>
    ;

// Expresión aritmética
Exp
    : Term ExpOptional
    << $0, nil >>
    ;

// Secuencia opcional de términos (0 o más)
ExpOptional
    : ExpTail ExpOptional
    | "empty"
    ;

// Operadores de suma o resta
ExpTail
    : plus Term
    | minus Term
    ;

// Término en la expresión
Term
    : Factor TermOptional
    << $0, nil >>
    ;

// Secuencia opcional de factores (0 o más)
TermOptional
    : TermTail TermOptional
    | "empty"
    ;

// Operadores de multiplicación o división
TermTail
    : times Factor
    | divide Factor
    ;

// Factor de la expresión
Factor
    : lparen Expression rparen
    << $1, nil >>
    | FactorOptional Cte
    << $1, nil >>
    | FactorOptional id
    <<
        func() (Attrib, error) {
            tok := $1.(*token.Token)

            // Regresa un nodo de expresión de tipo id con su nombre
            return &ast.ExpNode{
                Type:  "id",
                Value: string(tok.Lit),
            }, nil
        }()
    >>
    ;

// Signo opcional en el factor (0 o 1)
FactorOptional
    : plus
    | minus
    | "empty"
    ;

// Constante
Cte
    : cte_int
    <<
        func() (Attrib, error) {
            // Obtener el token constante
            cteTok := $0.(*token.Token)

            // Convertir la cadena de ASCIIs a un entero
            intVal, _ := strconv.Atoi(string(cteTok.Lit))
            
            // Crear un nodo de expresión
            return &ast.ExpNode{
                Type:  "int",
                Value: intVal,
            }, nil
        }()
    >>
    | cte_float
    <<
        func() (Attrib, error) {
            // Obtener el token constante
            cteTok := $0.(*token.Token)

            // Convertir la cadena de ASCIIs a un float
            floatVal, _ := strconv.ParseFloat(string(cteTok.Lit), 64)
            
            // Crear un nodo de expresión
            return &ast.ExpNode{
                Type:  "float",
                Value: floatVal,
            }, nil
        }()
    >>
    ;

// Condición if-else
Condition
    : if lparen Expression rparen Body ElseOptional semicolon
    ;

// Bloque else opcional (0 o 1)
ElseOptional
    : else Body
    | "empty"
    ;

// Ciclo while-do
Cycle
    : while lparen Expression rparen do Body semicolon
    ;

// Llamada a función
F_Call
    : id lparen F_CallOptional rparen semicolon
    ;

// Secuencia opcional de expresiones en una llamada a función (0 o 1)
F_CallOptional
    : F_CallList
    | "empty"
    ;

// Lista de expresiones en una llamada (1 o más)
F_CallList
    : Expression F_CallListTail
    ;

// Secuencia opcional de expresiones adicionales (0 o más)
F_CallListTail
    : comma Expression F_CallListTail
    | "empty"
    ;

// Instrucción de impresión
Print
    : print lparen PrintVarList rparen semicolon
    ;

// Lista de variables a imprimir (1 o más)
PrintVarList
    : PrintVar PrintVarListTail
    ;

// Secuencia opcional de variables a imprimir (0 o más)
PrintVarListTail
    : comma PrintVar PrintVarListTail
    | "empty"
    ;

// Variable a imprimir
PrintVar
    : Expression
    | cte_string
    ;